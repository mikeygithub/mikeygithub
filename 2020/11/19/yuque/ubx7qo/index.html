

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
  <title>算法笔记-树型结构 - 麦奇</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>麦奇</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/todo/">
                <i class="iconfont icon-plan"></i>
                代办
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-briefcase"></i>
                其他
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.yuque.com/aichihongdouheyumi/blog">
                    
                    在线创作
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/about/">
                    
                    关于麦奇
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://bing.ioliu.cn/v1/rand') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法笔记-树型结构">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Mikey
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-19 17:24" pubdate>
        2020年11月19日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      85
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法笔记-树型结构</h1>
            
            <div class="markdown-body">
              <p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1641450852816-7cb4f2cb-4b88-47e7-907e-e1b73ce097ab.png#clientId=ua77da9b5-c67d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=uc0766e80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=513&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27448&status=done&style=none&taskId=ud068ec94-ad42-4179-8df8-8ecb9fd4e81&title=&width=256.5" srcset="/img/loading.gif" lazyload alt="image.png"><br>​</p>
<h1 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h1><blockquote>
<p>在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了</p>
</blockquote>
<p>前序遍历-通过栈实现(先压入右结点)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>          stack.push(root);<br>          <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>              TreeNode tmp = stack.pop();<br>              list.add(tmp.val);<br>              <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>)<br>                  stack.push(tmp.right);<br>              <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>)<br>                  stack.push(tmp.left);<br>          &#125;<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>中序遍历-通过栈实现(一路向左把沿途结点压入栈)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>          <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;<br>              <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 一路向左把沿途结点压入栈</span><br>                  stack.push(root);<br>                  root = root.left;<br>              &#125;<br>              <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                  root = stack.pop();<span class="hljs-comment">// 弹出栈</span><br>                  list.add(root.val);<br>                  root = root.right;<span class="hljs-comment">// 转向右节点</span><br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>后序遍历-通过栈实现(前序先 push-left 再 reverse)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTreversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>          stack.push(root);<br>          <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>              TreeNode tmp = stack.pop();<br>              list.add(tmp.val);<br>              <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;<br>                  stack.push(tmp.left);<br>              &#125;<br>              <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) &#123;<br>                  stack.push(tmp.right);<br>              &#125;<br>          &#125;<br>          Collections.reverse(list);<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>广度优先-通过队列实现</p>
<blockquote>
<p>借助队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            TreeNode node = queue.poll();<span class="hljs-comment">//出队</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>深度优先-通过栈实现</p>
<blockquote>
<p>借助栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            TreeNode tmp = stack.pop();<br>            list.add(tmp.val);<br>            <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) stack.push(tmp.left);<br>            <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) stack.push(tmp.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="​平衡二叉树-简单"><a href="#​平衡二叉树-简单" class="headerlink" title="​平衡二叉树(简单)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树(简单)</a></h2><p>判断是否是平衡二叉树</p>
<blockquote>
<p>判断树是否为平衡二叉树</p>
</blockquote>
<p>测试用例<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance_binary_tree.jpg#crop=0&crop=0&crop=1&crop=1&id=HNXny&originHeight=221&originWidth=342&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload><br>输入：root = [3,9,20,null,null,15,7]<br>输出：true<br>解题思路</p>
<blockquote>
<p>平衡二叉树：左右子树高度差不超过一，根据这一特点，递归判断各个节点的子树是否符合条件，不满足则直接返回 false,直到递归完成。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode() &#123;<br>    &#125;<br><br>    TreeNode(<span class="hljs-keyword">int</span> val) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br><br>    TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为平衡二叉树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前节点树高度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​特定深度节点链表-中等"><a href="#​特定深度节点链表-中等" class="headerlink" title="​特定深度节点链表(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/list-of-depth-lcci">特定深度节点链表(中等)</a></h2><p>特定深度节点链表<br>题目描述</p>
<blockquote>
<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</p>
</blockquote>
<p>示例<br>输入：[1,2,3,4,5,null,7,8]</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   /  <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>    <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>

<p>/ 8<br>输出：[[1],[2,3],[4,5,7],[8]]<br>实现思路</p>
<blockquote>
<p>通过广度优先遍历对树进行逐层遍历构造链表，通过每一次获取当前队列长度读取当前层的元素个数(关键)</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode[] listOfDepth(TreeNode tree) &#123;<br><br>        List&lt;ListNode&gt; listNodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//广度优先遍历</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(tree);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<span class="hljs-comment">//队列大小（核心）</span><br>            ListNode head, tmp;<br>            head = tmp = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-comment">//链表临时头节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-comment">//循环当前层元素</span><br>                TreeNode treeNode = queue.poll();<span class="hljs-comment">//从对头取当前元素</span><br>                <span class="hljs-comment">//构建链表</span><br>                tmp.next = <span class="hljs-keyword">new</span> ListNode(treeNode.val);<br>                tmp = tmp.next;<br>                <span class="hljs-comment">//将下一层元素压入队列</span><br>                <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>) queue.add(treeNode.left);<br>                <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>) queue.add(treeNode.right);<br>            &#125;<br>            <span class="hljs-comment">//将每一条链表添加到list中</span><br>            listNodes.add(head.next);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> listNodes.toArray(<span class="hljs-keyword">new</span> ListNode[]&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​N-叉树的前序遍历-简单"><a href="#​N-叉树的前序遍历-简单" class="headerlink" title="​N 叉树的前序遍历(简单)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal">N 叉树的前序遍历(简单)</a></h2><p>N 叉树的前序遍历<br>题目描述<br>给定一个 N 叉树，返回其节点值的前序遍历。<br>例如，给定一个 3 叉树 :<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/n-tree.png#crop=0&crop=0&crop=1&crop=1&id=bgaBV&originHeight=502&originWidth=781&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload><br>返回其前序遍历: [1,3,5,6,2,4]。<br>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>   List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>       list.add(root.val);<br>       <span class="hljs-comment">//遍历子节点</span><br>       root.children.forEach(v -&gt; &#123;<br>           preorder(v);<br>       &#125;);<br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>       <span class="hljs-comment">//容器</span><br>       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> list;<br>       &#125;<br>       <span class="hljs-comment">//首个节点</span><br>       stack.push(root);<br>       <span class="hljs-comment">//迭代</span><br>       <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>           Node tmp = stack.pop();<span class="hljs-comment">//出栈</span><br>           list.add(tmp.val);<span class="hljs-comment">//插入值</span><br>           Collections.reverse(tmp.children);<span class="hljs-comment">//将子节点进行反转</span><br>           tmp.children.forEach(v -&gt; stack.push(v));<span class="hljs-comment">//压栈</span><br>       &#125;<br>       <span class="hljs-comment">//返回结果</span><br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>递归版</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ans.add(root.val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;root.children.size();i++)&#123;<br>            preorder(root.children.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​最大二叉树-中等"><a href="#​最大二叉树-中等" class="headerlink" title="​最大二叉树(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree">最大二叉树(中等)</a></h2><p>最大二叉树<br>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：<br>二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]<br>输出：返回下面这棵树的根节点：<br><br>      <span class="hljs-number">6</span><br>    /   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>     <span class="hljs-number">5</span><br>    <span class="hljs-string">\</span>    /<br>     <span class="hljs-number">2</span>  <span class="hljs-number">0</span><br>       <span class="hljs-string">\</span><br>        <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p>提示：给定的数组的大小在 [1, 1000] 之间。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//获得最大值</span><br>        <span class="hljs-keyword">int</span> maxIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[maxIndex] &lt; nums[i]) maxIndex = i;<br>        &#125;<br>        <span class="hljs-comment">//构造当前节点</span><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(nums[maxIndex]);<br>        <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-keyword">if</span> (maxIndex &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//左边数组还有值</span><br>            node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, maxIndex));<br>        <span class="hljs-comment">//构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxIndex &lt; nums.length - <span class="hljs-number">1</span>)<span class="hljs-comment">//右边数组还有值</span><br>            node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="hljs-number">1</span>, nums.length));<br>        <span class="hljs-comment">//返回当前节点</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​最大二叉树-II-中等"><a href="#​最大二叉树-II-中等" class="headerlink" title="​最大二叉树 II(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree-ii">最大二叉树 II(中等)</a></h2><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。<br>给出最大树的根节点 root。<br>就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：<br>如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], …, A[i-1]])<br>root 的右子树将被构建为 Construct([A[i+1], A[i+2], …, A[A.length - 1]])<br>返回 root 请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).<br>假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。<br>返回 Construct(B)。</p>
<p>示例 1：<br>输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2]<br>解释：A = [1,4,2,3], B = [1,4,2,3,5]<br>示例 2：<br>输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3]<br>解释：A = [2,1,5,4], B = [2,1,5,4,3]<br>示例 3：<br>输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3]<br>解释：A = [2,1,5,3], B = [2,1,5,3,4]<br>提示：<br>1 &lt;= B.length &lt;= 100</p>
<h2 id="​二叉搜索树的第-k-大节点-简单"><a href="#​二叉搜索树的第-k-大节点-简单" class="headerlink" title="​二叉搜索树的第 k 大节点(简单)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第 k 大节点(简单)</a></h2><p>给定一棵二叉搜索树，请找出其中第 k 大的节点。</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br><br>输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br>示例 <span class="hljs-number">2</span>:<br><br>输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>

<p>限制： 1 ≤ k ≤ 二叉搜索树元素个数<br>解题思路</p>
<blockquote>
<p>二叉搜索树、通过中许遍历得到递增序列、那么优先改变一下，从右子树先遍历即可得到递减序列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// clarification:  root == null?   k &lt;= 1?</span><br>        helper(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) helper(root.right, k);<br><br>        <span class="hljs-keyword">if</span> (++count == k) &#123;<br>            ans = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) helper(root.left, k);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​好叶子节点对的数量-中等"><a href="#​好叶子节点对的数量-中等" class="headerlink" title="​好叶子节点对的数量(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量(中等)</a></h2><p>给你二叉树的根节点 root 和一个整数 distance 。<br>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。<br>返回树中 好叶子节点对的数量 。<br>示例</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">输入: root = [1,2,3,null,4], distance = 3<br>       1<br>      / \<br>    <span class="hljs-number"> 2 </span>  3<br>      \<br>       4<br>输出: 1<br>解释：树的叶节点是<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 4 </span>，它们之间的最短路径的长度是<span class="hljs-number"> 3 </span>。这是唯一的好叶子节点对。<br></code></pre></div></td></tr></table></figure>

<p>解题思路</p>
<blockquote>
<p>父节点和子节点的距离是 1</p>
</blockquote>
<blockquote>
<p>对树后序遍历 ，需要返回这个节点到其下方所有叶子节点的距离</p>
</blockquote>
<blockquote>
<p>这样就可以将这个节点的左子树所有叶子节点和右子树所有叶子节点都凑个对</p>
</blockquote>
<blockquote>
<p>然后将所有叶子节点不超过距离的弄到一起返回</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>        dfs(root, distance);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//后续遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>        <span class="hljs-comment">//当前节点为空返回空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-comment">//叶子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>            list.add(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-comment">//左叶子节点的距离</span><br>        List&lt;Integer&gt; left = dfs(root.left, distance);<br>        <span class="hljs-comment">//判断是否超过distance</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : left) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//右叶子节点的距离</span><br>        List&lt;Integer&gt; right = dfs(root.right, distance);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : right) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l : left) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r : right) &#123;<br>                <span class="hljs-keyword">if</span> (l + r + <span class="hljs-number">2</span> &lt;= distance)<br>                    ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​具有所有最深节点的最小子树-中等"><a href="#​具有所有最深节点的最小子树-中等" class="headerlink" title="​具有所有最深节点的最小子树(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes">具有所有最深节点的最小子树(中等)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一个根为  root  的二叉树，每个节点的深度是 该节点到根的最短距离 。 如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。 一个节点的 子树 是该节点加上它的所有后代的集合。 返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。</p>
</blockquote>
<p><code>说的云里雾里，人话：最深叶子节点的最近公共祖先</code><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/sketch1.png#crop=0&crop=0&crop=1&crop=1&id=SBTR5&originHeight=614&originWidth=722&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4]<br>输出：[2,7,4]<br>解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。</p>
</blockquote>
<p>解题思路</p>
<blockquote>
<p>对于一个节点，如果左子树高度==右子树高度，这个节点就是答案，如果左子树高度&lt;右子树高度，查找右子树，否则查找左子树</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//为空返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> ldep = maxDepth(root.left), rdep = maxDepth(root.right);<span class="hljs-comment">//获取左右最大深度</span><br>            <span class="hljs-keyword">if</span> (ldep == rdep) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//相等返回</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ldep &gt; rdep) <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.left);<span class="hljs-comment">//左边深度大、查找左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.right);<span class="hljs-comment">//右边深度大、查找右边</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<span class="hljs-comment">//获取当前节点的最大深度</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​求和路径-中等"><a href="#​求和路径-中等" class="headerlink" title="​求和路径(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">求和路径(中等)</a></h2><p>题目描述<br>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。<br>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">      5<br>     / \<br>   <span class="hljs-number"> 4 </span>  8<br>   /   / \<br> <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br> /  \    / \<br>7   <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1<br></code></pre></div></td></tr></table></figure>

<p>返回:3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]<br>提示：节点总数 &lt;= 10000<br>解题思路</p>
<blockquote>
<p>求出当前节点为根路径是否满足，递归判断每个节点</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        helper(root, sum);<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) pathSum(root.left, sum);<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) pathSum(root.right, sum);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == node.val) count++;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) helper(node.left, sum - node.val);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) helper(node.right, sum - node.val);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树的层序遍历-中等"><a href="#​二叉树的层序遍历-中等" class="headerlink" title="​二叉树的层序遍历(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">二叉树的层序遍历(中等)</a></h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例： 二叉树：[3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br></code></pre></div></td></tr></table></figure>

<p>9 20 /  <br>15 7 返回其层次遍历结果：<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]<br>解题思路</p>
<blockquote>
<p>广度优先遍历，采用队列获取其每层的长度</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>            &#125;<br>            result.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树的最近公共祖先-中等"><a href="#​二叉树的最近公共祖先-中等" class="headerlink" title="​二叉树的最近公共祖先(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先(中等)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
</blockquote>
<p>解题思路</p>
<blockquote>
<p>对树 DFS 判断其目标节点是否存在，如果存在返回 true 寻找另一个节点，当两个节点都找到，递归返回获得其第一个公共节点</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || p == root || q == root)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//递归结束条件</span><br>        TreeNode left = lowestCommonAncestor(root.left,p,q);<span class="hljs-comment">//深度优先遍历左子树</span><br>        TreeNode right = lowestCommonAncestor(root.right,p,q);<span class="hljs-comment">//深度优先遍历右子树</span><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//找到节点将其返回</span><br>        <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : left;<span class="hljs-comment">//否则返回已查询到的节点</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树的直径-容易"><a href="#​二叉树的直径-容易" class="headerlink" title="​二叉树的直径(容易)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree">二叉树的直径(容易)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
</blockquote>
<p>示例 :<br>给定二叉树</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>

<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。<br>解题思路</p>
<blockquote>
<p>深度优先搜索，分别递归计算每个节点的左右子树的路径之和，默认值为 1 超过则更新，递归向上执行</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//记录最大路径</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<span class="hljs-comment">//方法入口</span><br>        ans = <span class="hljs-number">1</span>;<br>        depth(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//深度优先遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 访问到空节点了，返回0</span><br>        <span class="hljs-keyword">int</span> L = depth(node.left); <span class="hljs-comment">// 左儿子为根的子树的深度</span><br>        <span class="hljs-keyword">int</span> R = depth(node.right); <span class="hljs-comment">// 右儿子为根的子树的深度</span><br>        ans = Math.max(ans, L + R + <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算d_node即L+R+1 并更新ans</span><br>        <span class="hljs-keyword">return</span> Math.max(L, R) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树的锯齿形层次遍历-中等"><a href="#​二叉树的锯齿形层次遍历-中等" class="headerlink" title="​二叉树的锯齿形层次遍历(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">二叉树的锯齿形层次遍历(中等)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
</blockquote>
<p>例如： 给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">9</span> <span class="hljs-number">20</span><br> /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span> <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>

<p>返回锯齿形层次遍历如下：<br>[<br>[3],<br>[20,9],<br>[15,7]<br>]<br>解题思路</p>
<blockquote>
<p>广度优先遍历，每次将当前层元素出队，使用一个全局变量判断方向，调用 addLast 或者 addFirst。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; results)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= results.size()) &#123;<br>            LinkedList&lt;Integer&gt; newLevel = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            newLevel.add(node.val);<br>            results.add(newLevel);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                results.get(level).add(node.val);<br>            <span class="hljs-keyword">else</span><br>                results.get(level).add(<span class="hljs-number">0</span>, node.val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) DFS(node.left, level + <span class="hljs-number">1</span>, results);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) DFS(node.right, level + <span class="hljs-number">1</span>, results);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        DFS(root, <span class="hljs-number">0</span>, results);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ant = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> ant;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)queue.offer(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>            Collections.reverse(list);<br>            ant.add(list);<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ant;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树的最大深度-简单"><a href="#​二叉树的最大深度-简单" class="headerlink" title="​二叉树的最大深度(简单)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度(简单)</a></h2><p>解题思路</p>
<blockquote>
<p>递归每次递归返回+1,返回左右节点较大的值。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​验证二叉搜索树-中等"><a href="#​验证二叉搜索树-中等" class="headerlink" title="​验证二叉搜索树(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree">验证二叉搜索树(中等)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
</blockquote>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>示例 1:</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">输入:<br>     <span class="hljs-number">2</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br>示例 <span class="hljs-number">2</span>:<br><br>输入:<br>     <span class="hljs-number">5</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>

<p>解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。<br>解题思路</p>
<blockquote>
<p>获取左右子书的边界值，递归判断每一个节点是否满足条件</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//函数入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> helper(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//DFS</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;<br>        <span class="hljs-comment">//空节点返回</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//如果存在左子树则左子书最大值要小于当前节点值</span><br>        <span class="hljs-keyword">if</span> (lower != <span class="hljs-keyword">null</span> &amp;&amp; node.val &lt;= lower) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//如果存在左子树则左子书最大值要小于当前节点值</span><br>        <span class="hljs-keyword">if</span> (upper != <span class="hljs-keyword">null</span> &amp;&amp; node.val &gt;= upper) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//递归判断左子树</span><br>        <span class="hljs-keyword">if</span> (!helper(node.left, lower, val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//关键</span><br>        <span class="hljs-comment">//递归判断右子树</span><br>        <span class="hljs-keyword">if</span> (!helper(node.right, val, upper)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//关键</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​二叉树中的最大路径和-困难"><a href="#​二叉树中的最大路径和-困难" class="headerlink" title="​二叉树中的最大路径和(困难)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">二叉树中的最大路径和(困难)</a></h2><p>题目描述</p>
<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。</p>
</blockquote>
<p>思路</p>
<blockquote>
<p>后序递归遍历，判断其左右子树最大值，依此递归</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = Integer.MIN_VALUE;<span class="hljs-comment">//记录结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        max(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//递归结束</span><br>        <span class="hljs-keyword">int</span> left = Math.max(max(root.left), <span class="hljs-number">0</span>);<span class="hljs-comment">//左子树最大值（负数直接不取，所以和0比较）</span><br>        <span class="hljs-keyword">int</span> right = Math.max(max(root.right), <span class="hljs-number">0</span>);<span class="hljs-comment">//右子树最大值（负数直接不取，所以和0比较）</span><br>        ans = Math.max(ans, left + right + root.val);<span class="hljs-comment">//是否大于当前的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(left, right) + root.val;<span class="hljs-comment">//返回最大值</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​从前序与中序遍历序列构造二叉树-中等"><a href="#​从前序与中序遍历序列构造二叉树-中等" class="headerlink" title="​从前序与中序遍历序列构造二叉树(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树(中等)</a></h2><blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
</blockquote>
<p>注意:<br>你可以假设树中没有重复的元素。<br>例如，给出<br>前序遍历 preorder =[3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>    采用递归</p>
<figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">preorder = <span class="hljs-comment">[3,9,20,15,7]</span><br>inorder = <span class="hljs-comment">[9,3,15,20,7]</span><br>首先根据 preorder 找到根节点是 3<br><br>然后根据根节点将 inorder 分成左子树和右子树<br>左子树<br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>把相应的前序遍历的数组也加进来<br>左子树<br>preorder<span class="hljs-comment">[9]</span><br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>preorder<span class="hljs-comment">[20 15 7]</span><br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题<br>然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//存储值对应的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)map.put(inorder[i], i);<span class="hljs-comment">//存入map</span><br>        <span class="hljs-keyword">return</span> buildTree(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>,map);<span class="hljs-comment">//递归调用</span><br>    &#125;<br>    <span class="hljs-comment">//构建</span><br>    <span class="hljs-function">TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> preEnd,<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//下标超过则停止(递归结束条件)</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preStart]);<span class="hljs-comment">//构建结点</span><br>        <span class="hljs-keyword">int</span> inRoot = inMap.get(root.val);<span class="hljs-comment">//根结点下标</span><br>        <span class="hljs-keyword">int</span> numsLeft = inRoot - inStart;<span class="hljs-comment">//重新定义左边(左子树有多少个节点)</span><br>        root.left = buildTree(preorder, preStart + <span class="hljs-number">1</span>, preStart + numsLeft,inorder, inStart, inRoot - <span class="hljs-number">1</span>, inMap);<span class="hljs-comment">//递归调用</span><br>        root.right = buildTree(preorder, preStart + numsLeft + <span class="hljs-number">1</span>, preEnd,inorder, inRoot + <span class="hljs-number">1</span>, inEnd, inMap);<span class="hljs-comment">//递归调用</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//返回根节点</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="​不同的二叉搜索树-II-中等"><a href="#​不同的二叉搜索树-II-中等" class="headerlink" title="​不同的二叉搜索树 II(中等)"></a>​<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II(中等)</a></h2><p>解题思路</p>
<blockquote>
<p>回溯</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> generateTrees(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        List&lt;TreeNode&gt; allTrees = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            allTrees.add(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> allTrees;<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举可行根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// 获得所有可行的左子树集合</span><br>            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 获得所有可行的右子树集合</span><br>            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br>            <span class="hljs-keyword">for</span> (TreeNode left : leftTrees) &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode right : rightTrees) &#123;<br>                    TreeNode currTree = <span class="hljs-keyword">new</span> TreeNode(i);<br>                    currTree.left = left;<br>                    currTree.right = right;<br>                    allTrees.add(currTree);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> allTrees;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//bfs取每一层的最右边节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span>(i==size-<span class="hljs-number">1</span>)ans.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">求根节点到叶节点数字之和</a></h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> prevSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = prevSum * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">算法相关</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">刷题记录</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/19/yuque/sqg7xy/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">刷题笔记-链表结构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/19/yuque/vsbnw5/">
                        <span class="hidden-mobile">刷题笔记-二分搜索</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Copyright © 2017-2021 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> And <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> Core on Github Page 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        桂ICP备2020009931号-1
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>桂公网安备2020009931号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
